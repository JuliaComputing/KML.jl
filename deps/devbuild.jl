# Generate as much code as we can directly from the KML schema file.
using Pkg
Pkg.activate(@__DIR__)

using Downloads: download
using Dates
using XML

doc = Document(download("http://schemas.opengis.net/kml/2.2.0/ogckml22.xsd"))

INDENT = "    "

datatypes = Dict(
    "string" => String,
    "double" => Float64,
    "int" => Int,
    "boolean" => Bool
)

function write_generated()
    open(touch(joinpath(@__DIR__, "..", "src", "generated.jl")), "w") do io
        println(io, """
        #-----------------------------------------------------------------------------#
        # This file is generated by `../deps/devbuild.jl`.  DO NOT EDIT DIRECTLY.
        #
        # Created at: $(now())
        #-----------------------------------------------------------------------------#
        """)

        for node in children(doc.root)
            println(io, "#-----------------------------------------------------------------------------# ", typeof(node))
            print(io, "# ", replace(repr("application/xml", node), '\n' => "\n#")[1:end-1])
            if node isa Element
                if tag(node) == "element"
                    print_element(io, node)
                elseif tag(node) == "simpleType"
                    print_simpletype(io, node)
                end
            end
            println(io, '\n')
        end
    end
end

#-----------------------------------------------------------------------------# print_element
function print_element(io, node)
    if hasproperty(node, :type) && haskey(datatypes, node.type)
        T = uppercasefirst(node.name)
        println(io, "struct $T")
        println(io, "    value::", datatypes[node.type])
        if hasproperty(node, :default)
            println(io, "    $T(value=", node.default, ") = new(value)")
        end
        println(io, "end")
    end
end

#-----------------------------------------------------------------------------# print_simpletype
function print_simpletype(io, node)
    r = filter(x -> tag(x) == "restriction", children(node))
    if length(r) == 1
        restriction = r[1]
        base = restriction.base
        if haskey(datatypes, base)
            T = uppercasefirst(node.name)
            println(io, "struct $T")
            println(io, "    value::", datatypes[base])
            println(io, "    function $T(value)")
            for x in children(restriction)
                print_assertion(io, x)
            end
            if all(x -> tag(x) == "enumeration", children(restriction))
                s = join(map(x -> repr(x.value), children(restriction)), ", ")
                println(io, "        @assert value ∈ [$s]")
            end
            println(io, "        new(value)")
            println(io, "    end")
            println(io, "end")
        end
    end
end
function print_assertion(io, node)
    tag(node) == "minInclusive" && println(io, INDENT^2, "@assert $(node.value) ≤ value")
    tag(node) == "minExclusive" && println(io, INDENT^2, "@assert $(node.value) < value")
    tag(node) == "maxInclusive" && println(io, INDENT^2, "@assert $(node.value) ≥ value")
    tag(node) == "maxExclusive" && println(io, INDENT^2, "@assert $(node.value) > value")
end


#-----------------------------------------------------------------------------# run
write_generated()

# #-----------------------------------------------------------------------------# print_simpletype
# base_types = Dict(
#     "double" => Float64,
#     "boolean" => Bool,
#     "integer" => Int,

#     "string" => String,
#     "hexBinary" => String
# )

# function print_simpletype(io, element)
#     T = replace(uppercasefirst(element.name), ":" => "_", "." => "_")
#     restriction = filter(x -> occursin("restriction", tag(x)), children(element))
#     if !isempty(restriction)
#         r = restriction[1]
#         base = base_types[r.base]
#         println(io, "struct ", T)
#         println(io, "    value::", base)
#         assertions = filter(x -> occursin("Inclusive", tag(x)), children(r))
#         if !isempty(assertions)
#             indent = "    "
#             println(io, indent, "function ", T, "(value)")
#             for a in assertions
#                 tag(a) == "minInclusive" && println(io, indent^2, "@assert value ≥ ", a.value)
#                 tag(a) == "minExclusive" && println(io, indent^2, "@assert value > ", a.value)
#                 tag(a) == "maxInclusive" && println(io, indent^2, "@assert value ≤ ", a.value)
#                 tag(a) == "maxExclusive" && println(io, indent^2, "@assert value < ", a.value)
#             end
#             enum_values = filter(x -> occursin("enumeration", tag(x), assertions))
#             println(io, indent, "end")
#         end
#         println(io, "end")
#     end
# end
